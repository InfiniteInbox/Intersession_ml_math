\documentclass[12pt, a4paper]{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}


\title{An Exploration into Linear Algebra}
\author{Yash Money, Imran "Vince McMath" Iftikar}
\date{Idk man, I just work here}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2,
  frame=tb
}

\begin{document}
\maketitle

\section{Basic Matrix Code}

To begin, we have will create code that represents matrices and
performs elementary matrix operations, such as computing the inverse, 
multiplying, and adding. 

We will utilise python to do so. Python has a data structure known as a "list" or an "array."
These are essentially a collection of indexed data that can be manipulated. Lists may contain sublists; it is in this way
that we can represent a "matrix" in python, for indeed, a matrix is nothing but a collection of row/column vectors, which themselves
can be represented as an individual python list. 

We have decided to represent a matrix as a collection of row vectors.

For example consider the following matrix, $ A \in \mathbb{R}^{m\times n} $: 

\begin{equation*}
    A =
\begin{bmatrix}
a_{1}  & a_{2} & a_{3} & ... & a_{n}\\
b_{1}  & b_{2} & b_{3} & ... & b_{n}\\
...  & ...& ... & ... & ...\\
m_{1}  & m_{2} & m_{3} & ... & m_{n}\\
\end{bmatrix}
\end{equation*}

with $m$ rows and $n$ columns. We choose to represent the same matrix, $A$ pythonically in the following way: \newline

\begin{lstlisting}
array = [
    [a1, a2, a3, ..., aN],
    [b1, b2, b3, ..., bN],
    [c1, c2, c3, ..., cN],
    ...,
    [m, m2, m3, ..., mN],
]    
\end{lstlisting}

In this way, each sublist is a row of the matrix. 

In the following we, will discuss how to code basic matrix operations using this data structure.

\subsection{Multiplying a Matrix by a Scalar}

One of the most crucial elements of matrix arithmetic is the ability to multiply a given matrix by a scalar. 
When doing this, the following will hold true:

\begin{equation*}
    \forall \lambda \in \mathbb{R}, \forall A \in \mathbb{R}^{m\times n},  \lambda A = 
    \begin{bmatrix}
        \lambda a_{1}  & \lambda a_{2} &  \lambda a_{3} & ... & \lambda a_{n}\\
        \lambda b_{1}  & \lambda b_{2} & \lambda b_{3} & ... & \lambda b_{n}\\
        ...  & ...& ... & ... & ...\\
        \lambda m_{1}  & \lambda m_{2} & \lambda m_{3} & ... & \lambda m_{n}\\
    \end{bmatrix},
\end{equation*}

This is a rather simple problem to tackle. Simply, we iterate through each row of the matrix, and then through each
element (column) within that row, multiplying each entry by a given $\lambda$ as we iterate. 
This produces a matrix that has been multiplied by lambda. The code is as follows: \newline

\begin{lstlisting}
def matrix_by_scalar(matrix1, scalar_quantity):
    
    '''
    TAKES: 
        A matrix of the form outlined above, matrix1
        A scalar_quantity by which the matrix will be multiplied
    RETURNS:
        A matrix of the form outlined above
    '''
    try:
        if (isinstance(scalar_quantity, int)) or (isinstance(scalar_quantity, float)): 
        # O(1) we wcheck if the scalar element is a valid real number; if not, we raise an error.

            return  list([element * scalar_quantity for element in row] \
                for row in matrix1) # O(n**2) This comprehension multiplies each element of each row by the scalar and thus has a time complexity of n**2
    
        else: raise ValueError(f"Argument passed: '{scalar_quantity}'. Error: Expected argument of type 'int' or 'float' ") # error raised
    except: # In Case something goes wrong; biggest error here is the potential for incorrect args passed
        print("something went wrong - likely the matrix argument was incorrect") 

\end{lstlisting}

\subsection{Adding Two Matrices}

The addition of matrices is an elementwise one, and therefore it is easy to implemenent iteratively and makes lots of intuiative sense. 
What is meant by elementwise is that we can handle each element individually; in the case of matrix addition, 
we add each element of a given matrix to the corresponding element of a separate matrix. We can assert that the matrices must 
therefore be the of the same dimension to be added. 

Essentially, we have the following for $ \forall A, B \in \mathbb{R}^{m\times n}, $ where $i = 1,...,m$  and $j = 1,...,n$      

\begin{eqnarray*}
    A + B & = & \begin{bmatrix}
        A_{1,1}  & A_{1,2} & ... & A_{1,j}\\
        A_{2,1} & A_{2,2} & ... & A_{2,j}\\
        ... & ... & ... & ... \\
        A_{i,1} & A_{i,2} & ... & A_{i,j}
    \end{bmatrix} + \begin{bmatrix}
        B_{1,1}  & B_{1,2} & ... & B_{1,j}\\
        B_{2,1} & B_{2,2} & ... & B_{2,j}\\
        ... & ... & ... & ... \\
        B_{i,1} & B_{i,2} & ... & B_{i,j}
    \end{bmatrix} \\
    & = & \begin{bmatrix}
        A_{1,1} + B_{1,1} & A_{1,2} + B_{1,2} & ... & A_{1,j} + B_{1,j} \\
        A_{2,1} + B_{2,1} & A_{2,2} + B_{2,2} & ... & A_{2,j} + B_{2,j} \\
        ... & ... & ... & ... & \\
        A_{i,1} + B_{i,1} & A_{i,2} + B_{i,2} & ... & A_{i,j} + B_{i,j} \\
    \end{bmatrix}
\end{eqnarray*}

The code looks as follows:

\begin{lstlisting}
def add_matrices(mat1, mat2): 

    '''
    TAKES:
        two matrices of the standard form outlined previously, mat1 and mat2
            They must be of the same dimensions
    RETURNS:
        A single matrix of the same dimensions as mat1 and mat2, where this matrix is the sum of mat1 and mat2
    '''

    if (len(mat1) == (len(mat2)) and (len(mat1[0]) == len(mat2[0]))): # check to see if possible to add the two lists, as their dimensions must be the same

        '''
        The following is just a long list comprehension that iterates through each matrix and adds corresponding elements. It then appends these to "l", which is what is ultimately what is returned
        '''
        # basically just two for loops
        l = list([mat1[row][col]+mat2[row][col] \ 
            for col in range(len(mat1[0]))] \ 
            for row in range(len(mat1)))
        return l 
        # Intuitively subtraction is very similar: the "+" must be turned to a "-"

    else: # if the matrices are not of the same size.
        raise ValueError("Args are different size and thus cannot be added")

\end{lstlisting}

This code will hold for subtraction as well, because of the following identity:

\begin{eqnarray*}
    A - B & = & \begin{bmatrix}
        A_{1,1}  & A_{1,2} & ... & A_{1,j}\\
        A_{2,1} & A_{2,2} & ... & A_{2,j}\\
        ... & ... & ... & ... \\
        A_{i,1} & A_{i,2} & ... & A_{i,j}
    \end{bmatrix} - \begin{bmatrix}
        B_{1,1}  & B_{1,2} & ... & B_{1,j}\\
        B_{2,1} & B_{2,2} & ... & B_{2,j}\\
        ... & ... & ... & ... \\
        B_{i,1} & B_{i,2} & ... & B_{i,j}
    \end{bmatrix} \\
    & = & \begin{bmatrix}
        A_{1,1} - B_{1,1} & A_{1,2} - B_{1,2} & ... & A_{1,j} - B_{1,j} \\
        A_{2,1} - B_{2,1} & A_{2,2} - B_{2,2} & ... & A_{2,j} - B_{2,j} \\
        ... & ... & ... & ... & \\
        A_{i,1} - B_{i,1} & A_{i,2} - B_{i,2} & ... & A_{i,j} - B_{i,j} \\
    \end{bmatrix}
\end{eqnarray*}

where $ \forall A, B \in \mathbb{R}^{m\times n}, $ and $i = 1,..., m$, $j = 1,..., n$.

This implies that we must merely change the elementwise addition in our code to subtraction in order to create
a function that subracts two matrices.

\subsection{Transpose of a Matrix}

The tranpose of a matrix is a modification to its structure such that rows become columns and vice versa. That is, the first row of a given matrix
$A$ will be the first column of it's transpose, $A^{T}$, the second row of $A$ will be the second column of $A^{T}$, and so forth and so on.
\newline
\begin{eqnarray*}
    A &=& \begin{bmatrix}
        A_{1,1}  & A_{1,2} & ... & A_{1,j}\\
        A_{2,1} & A_{2,2} & ... & A_{2,j}\\
        ... & ... & ... & ... \\
        A_{i,1} & A_{i,2} & ... & A_{i,j}
    \end{bmatrix} \in \mathbb{R}^{m\times n}, i=1,...,\text{ and }j=1,...,n
    \\
    \\
    \text{Then,}
    \\
    \\
    A^{T} &=& \begin{bmatrix}
        A_{1,1}  & A_{2,1} & ... & A_{i,1}\\
        A_{1,2} & A_{2,2} & ... & A_{i,2}\\
        ... & ... & ... & ... \\
        A_{1,j} & A_{2,j} & ... & A_{i,j}
    \end{bmatrix} \in \mathbb{R}^{m\times n}, i=1,...,\text{ and }j=1,...,n
\end{eqnarray*}

In the case of square matrices, we can state the matrix has been "flipped" over it's main diagonal, 
or the diagonal elements running from top-left to bottom-right.
\newline
The transpose, as with matrix addition/subtraction and multiplying by a scalar, is rather trivial to implement. 
We iterate through the columns of a matrix, and return them to the user as rows of a new matrix, which is the tranpose. 
In regards to greabbing the columns of a matrix: python provides no way to index a column as simply as one can index a row. 
This is because, as we have represented matrices with row vectors, the columns are comprised of elements from mutliple different rows. 
Therefore, we construct a function that enables us to quickly "grab" a column from a matrix given its index. 

\begin{lstlisting}
def get_col(matrix_2d, _index):

    return list(row[_index] for row in matrix_2d) # O(n) this simply grabs the column from the specified index. 

    # full time O(n)

def transpose(matrix):

    new_array = [get_col(matrix, i) for i in range(len(matrix[0]))] # O(n) and nested O(n), becomes O(n**2). takes a column and makes it a row
    return new_array

\end{lstlisting}

\subsection{Row Reduction: Echelon/Upper Triangle Form}

\subsection{Row Reduction: Row Echelon Form (REF)}

\subsection{Row Reduction: Reduced Row Echelon Form (RREF)}

\subsection{Finding the Determinant}

\subsection{Inverting a Matrix}

\subsection{Multiplying Two Matrices}

\section{Vector(Sub)Spaces Pythonically}

\subsection{General Introduction to Vector Subspaces}

A vector space is special type of a group that contains both an inner and outer operation, which are addition and multiplication by a scalar, respectively.


\subsection{Issues when Representing Subspaces Pythonically}

\subsection{Uses Basis Vectors}


\section{Representing Linear Mappings Pythonically}

\section{More Advanced Matrix Operations}

\section{Projections}

\subsection{Solving Homogeneous Systems}

\subsection{Finding Eigenvalues and Eigenvectors Of A Matrix}

\subsection{Finding the Eiegendecomposition}

\subsection{Finding the Singular Value Decomposition}

\end{document}