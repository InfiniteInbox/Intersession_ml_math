\documentclass[12pt, a4paper]{article}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}


\title{An Exploration into Linear Algebra}
\author{Yash Money, Imran Iftikar}
\date{Idk man, I just work here}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=2,
  frame=tb
}

\begin{document}
\maketitle

\section{Basic Matrix Code}

To begin, we have will create code that represents matrices and
performs elementary matrix operations, such as computing the inverse, 
multiplying, and adding. 

We will utilise python to do so. Python has a data structure known as a "list" or an "array."
These are essentially a collection of indexed data than can be manipulated. Lists may contain sublists; it is in this way
that we can represent a "matrix" in python, for indeed, a matrix is nothing but a collection of row/column vectors, which themselves
can be represented as an individual python lists. 

We have decided to represent a matrix as a collection of row vectors.

For example consider the following matrix, $ A \in \mathbb{R}^{m\times n} $: 

\begin{equation*}
    A =
\begin{bmatrix}
a_{1}  & a_{2} & a_{3} & ... & a_{n}\\
b_{1}  & b_{2} & b_{3} & ... & b_{n}\\
...  & ...& ... & ... & ...\\
m_{1}  & m_{2} & m_{3} & ... & m_{n}\\
\end{bmatrix}
\end{equation*}

with $m$ rows and $n$ columns. We choose to represent the same matrix, $A$ pythonically in the following way:

\begin{lstlisting}


    
\end{lstlisting}

\subsection{Matrix By Scalar}

\begin{lstlisting}
  def matrix_by_scalar(matrix1, scalar_quantity):

  if (isinstance(scalar_quantity, int)) or (isinstance(scalar_quantity, float)): # O(1) checks if the second arg is valid

      return  list([element * scalar_quantity for element in row] \
              for row in matrix1) # O(n**2) Multiplies each element of each row by the scalar and thus has a time complexity of n**2
  
  else: raise ValueError(f"Argument passed: '{scalar_quantity}'. Error: Expected argument of type 'int' or 'float' ") # error raised

  # full time O(n**2)
\end{lstlisting}

\subsection{Adding Matricies}

\begin{lstlisting}
  def add_matrices(mat1, mat2): 

    if (len(mat1) == (len(mat2)) and (len(mat1[0]) == len(mat2[0]))): # check to see if possible to add the two lists. constant time i think

        # the following is a rather long list comprehension. it just adds each row and col of the two lists together
        # basically just two for loops
        l = list([mat1[row][col]+mat2[row][col] \
            for col in range(len(mat1[0]))] \
            for row in range(len(mat1))) # O(n**2)
        return l
    
    else:
        raise ValueError("Args are different size and thus cannot be added")
    
    # full time O(n**2)
\end{lstlisting}

\subsection{Subtracting Matricies}

\begin{lstlisting}
  def subtract_matrices(mat1, mat2): # subtracts second term from first

    if (len(mat1) == (len(mat2)) and (len(mat1[0]) == len(mat2[0]))): # check to see if possible to add the two lists. constant time i think

        # the following is a rather long list comprehension. it just adds each row and col of the two lists together
        # basically just two for loops
        l = list([mat1[row][col]-mat2[row][col] \
            for col in range(len(mat1[0]))] \
            for row in range(len(mat1))) # O(n**2)
        return l

    else:
        raise ValueError("Args are different size and thus cannot be subtraction")
    
    # full time, O(n**2)
\end{lstlisting}

\subsection{Transpose of a matrix}

\begin{lstlisting}
  def transpose(matrix):

    new_array = [get_col(matrix, i) for i in range(len(matrix[0]))] # O(n) and nested O(n), becomes O(n**2). takes a column and makes it a row
    return new_array

    # full time O(n**2)
\end{lstlisting}

\subsection{Echelon}

\begin{lstlisting}
  def echelon(matrix): 
    
    for col_index in range(len(matrix[0])): # Indiv O(n), Overall (n**3) the formula I devised uses columns, so I start with that. 
        
        col = get_col(matrix, col_index) # O(n) we grab the column using the index from the above for loop

        '''
        
        the following bit of code looks for places where there might be zeroes in the diagonal.
        if there are, and we do not handle for it, we get a dividing by zero error

        thus, the following code is quite necessary.  
        
        '''
        if col_index <= len(matrix): # O(1) we only need to look for zeroes in the first square - that is, if the matrix is longer than tall, it is uncessary to check all columns

            if all((i == 0) for i in col[col_index:]): #O(n) if the entire column is filled with zeroes, we call continue and the program returns to the initial for loop, and goes to the next column
                continue 
            
            elif col[col_index] == 0: # O(1) if one of the elements on the diagonal is zero - this is where the dividing by zero error occurs so we need to handle this
                ''' 
                here we iterate through all of the rows below the diagonal. 
                if we find a row that doesn't contain a zero in the diagonal column index, 
                we will swap them
                '''
                for i in range(len(col[col_index:])): #O(n) 
                    if col[col_index:][i] != 0: # O(1)
                        row_idx = col_index+i # O(1)
                        break 
                
                # the below line of code simple swaps the rows
                matrix[col_index], matrix[row_idx] = matrix[row_idx], matrix[col_index] # O(1)


        '''
        the following for loop is where the actual formula happens
        the algorithm works as follows:

        assume we have an array, 
        we have the nth column and we want to make all elements of that column below 
        the nth row into 0

        say n =0 then we have:

        c1 = [           desired_c1 = [
              3                         3
              4                         4
              3                         0
              7                         0
              2                         0
                ]                         ]
        
        we can achieve this via subtracting a scalar multiple of the row such that we get 0
        ex. row 2. we can achieve row 1, col 2 equaling 0 by 
        subtracting row 1 * matrix[row1_idx][col2_idx]/matrix[row1_idx][row_idx]
        
        '''
        for row_index in range(len(col)): # O(n) we iterate through row of each colum we have grabbed earlier

            '''
            remember, we only want to turn the rows below
            the diagonal into 0. thus, we check if the row is indeed one we one to turn into 0
            if it is not, its idx will be less than the column idx
            if that proves to be true, we will simple pass
            '''

            if row_index <= col_index: #O(1)n checks if the row is one we do not want to turn to 0
                '''
                the following if statement is unnecessary, as I could have explicity called:
                    matrix[col_index][col_index] when I called denominator later
                    matrix[col_index] when I call raw_subtractant_row later
                    however, will keep this code for readability, as I find this easier to understand.
                '''
                if row_index == col_index: #O(1)
                    denominator = matrix[row_index][col_index] #O(1)
                    raw_subtractant_row = matrix[row_index] #O(1)
                pass              

            else:
                '''
                here we actually do the conversion to 0
                this finds teh numerator of the scalar we will multiply the subtractant row by
                then we will simply create the final subtractant row
                then we simply subtract the two rows, resulting in a 0
                we then replace the old row with the new one.                
                '''
                row_to_sub_from = matrix[row_index] # O(1)
                numerator = matrix[row_index][col_index] #O(1)


                subtractant = row_by_scalar(raw_subtractant_row, (numerator/denominator)) # O(n)
                subbed_row = subtract_row(row_to_sub_from, subtractant) # O(1)

                matrix[row_index] = subbed_row # O(1)
    
    return matrix
    
    # Full time: O(n**3)
\end{lstlisting}

\subsection{Row Echelon Form}

\begin{lstlisting}
  def ref(matrix):

    # takes matrix of form outlined in flowerbox
    # returns matrix of form outlined in flowerbox, but in ref form

    # builds off of the echelon function, which merely produces an upper triangle
    # ref turns that into an upper triangle such that the leading nonzero element of each row is 1
    
    matrix = echelon(matrix) # we make sure that the input is in upper triangle by applying echelon O(n**3)
    # (this could be put in an if statement to potentially improve time)

    mindim = min(len(matrix), len(matrix[0])) - 1 # here we find the minimum dimension of the matrix

    for idx, row in enumerate(matrix): # we iterate through each row of the matrix and get its index as well O(n)
        # enumerate is O(n) 
        # for loop itself in O(n), so 2O(n) total or just O(n)

        if idx > mindim: # if matrix is longer than wider, we want to finish without iterating through the lower levels
            return matrix # we just return if that is the case, becuase this will be in ref form
        if matrix[idx][idx] !=0: # if the leading element of each row is not 0
            matrix[idx] = row_by_scalar(row, (1/row[idx])) # we will multiply the entire row by the inverse of the leading element O(n)

    return matrix # returns the matrix

    # Full time: O(n**3) with echelon at start, O(n**2 otherwise)
\end{lstlisting}

\subsection{Row Reduced Echelon Form}

\begin{lstlisting}
  def ref(matrix):

    # takes matrix of form outlined in flowerbox
    # returns matrix of form outlined in flowerbox, but in ref form

    # builds off of the echelon function, which merely produces an upper triangle
    # ref turns that into an upper triangle such that the leading nonzero element of each row is 1
    
    matrix = echelon(matrix) # we make sure that the input is in upper triangle by applying echelon O(n**3)
    # (this could be put in an if statement to potentially improve time)

    mindim = min(len(matrix), len(matrix[0])) - 1 # here we find the minimum dimension of the matrix

    for idx, row in enumerate(matrix): # we iterate through each row of the matrix and get its index as well O(n)
        # enumerate is O(n) 
        # for loop itself in O(n), so 2O(n) total or just O(n)

        if idx > mindim: # if matrix is longer than wider, we want to finish without iterating through the lower levels
            return matrix # we just return if that is the case, becuase this will be in ref form
        if matrix[idx][idx] !=0: # if the leading element of each row is not 0
            matrix[idx] = row_by_scalar(row, (1/row[idx])) # we will multiply the entire row by the inverse of the leading element O(n)

    return matrix # returns the matrix

    # Full time: O(n**3) with echelon at start, O(n**2 otherwise)

\section{Representing Subspaces Pythonically}

\section{Representing Linear Mappings Pythonically}

\section{More Advanced Matrix Operations}

\subsection{Solving Homogeneous Matricies}

\subsection{Finding Eigenvalues and Eigenvectors Of A Matrix}

\subsection{Finding the Eiegendecomposition}

\subsection{Finding the Singular Value Decomposition}

\end{document}